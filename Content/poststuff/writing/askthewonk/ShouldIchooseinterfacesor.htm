<!-- Published by Fog Creek Software CityDesk MAYOWDQEAUJJTIIX/EB053B17/8 -->
<html>
<head>
	<title>Should I choose interfaces or base classes for polymorphism?</title>
</head>
<body>

		    
<b>Q. Should I choose interfaces or base classes for polymorphism?</b>
<p>
<i>Asked by Michael Weinhardt. Answered by the Wonk on December 22, 2002</i>
<P style="MARGIN-RIGHT: 0px">
		 </P>
		  
		<p style="MARGIN-RIGHT: 0px"><b>A.</b> <P>Michael Weinhardt asked me a darn good question the other day. He wanted to know why some parts of .NET use interfaces and some use base classes for their polymorphic behavior. Both of these styles of architecture can be found in the .NET design-time architecture. The core of the design-time architecture is the IComponent interface from the System.ComponentModel namespace. An implementation of the IComponent interface allows a .NET class to be shown on the Toolbox, dropped onto a design surface and manipulated via the Property Browser. All this is based on the ability to set the Site property from the IComponent interface:</P>
<P class=MsoNormal><SPAN style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'">interface</SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'"> <SPAN style="COLOR: black">System</SPAN>.<SPAN style="COLOR: black">ComponentModel</SPAN>.<SPAN style="COLOR: black">IComponent</SPAN> : <SPAN style="COLOR: black">IDisposable</SPAN> {<BR></SPAN><B><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'">&nbsp; <SPAN style="COLOR: black">ISite</SPAN> <SPAN style="COLOR: black">Site</SPAN> { <SPAN style="COLOR: blue">get</SPAN>; <SPAN style="COLOR: blue">set</SPAN>; }<BR></SPAN></B><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'">&nbsp; <SPAN style="COLOR: blue">public</SPAN> <SPAN style="COLOR: blue">event</SPAN> <SPAN style="COLOR: black">EventHandler</SPAN> <SPAN style="COLOR: black">Disposed</SPAN>;<BR>}</SPAN></P>
<P>In this case, VS.NET uses the IComponent interface (and Reflection) to hook any component into its design environment without needing any implementation details. On the other hand, to help VS.NET convert back and forth between strings in the Property Browser and properties of custom types in your components (or controls), a component can expose a custom type converter class using an attribute:</P>
<P class=MsoNormal><B><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'">[<SPAN style="COLOR: black">TypeConverterAttribute</SPAN>(<SPAN style="COLOR: blue">typeof</SPAN>(<SPAN style="COLOR: black">FractionTypeConverter</SPAN>))]<BR></SPAN></B><SPAN style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'">class</SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'"> <SPAN style="COLOR: black">Fraction</SPAN> {...};</SPAN></P>
<P>In this case, VS.NET requires help from the FractionTypeConverter to translate strings of the form "4/5" into instances of the Fraction class:</P>
<P class=MsoNormal><B><SPAN style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'">class</SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'"> <SPAN style="COLOR: black">FractionTypeConverter</SPAN> : <SPAN style="COLOR: black">TypeConverter</SPAN> {<BR></SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'">&nbsp; <SPAN style="COLOR: blue">public</SPAN> <SPAN style="COLOR: blue">override</SPAN> <SPAN style="COLOR: blue">object</SPAN> <SPAN style="COLOR: black">ConvertFrom</SPAN>(<SPAN style="COLOR: black">...</SPAN>) {<BR></SPAN></B><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'">&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: blue">string</SPAN> <SPAN style="COLOR: black">from</SPAN> = (<SPAN style="COLOR: blue">string</SPAN>)<SPAN style="COLOR: blue">value</SPAN>;<BR>&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: blue">int</SPAN> <SPAN style="COLOR: black">slash</SPAN> = <SPAN style="COLOR: black">from</SPAN>.<SPAN style="COLOR: black">IndexOf</SPAN>("/");<BR>&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: blue">int</SPAN> <SPAN style="COLOR: black">numerator</SPAN> = <SPAN style="COLOR: blue">int</SPAN>.<SPAN style="COLOR: black">Parse</SPAN>(<SPAN style="COLOR: black">from</SPAN>.<SPAN style="COLOR: black">Substring</SPAN>(0, <SPAN style="COLOR: black">slash</SPAN>));<BR>&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: blue">int</SPAN> <SPAN style="COLOR: black">denominator</SPAN> = <SPAN style="COLOR: blue">int</SPAN>.<SPAN style="COLOR: black">Parse</SPAN>(<SPAN style="COLOR: black">from</SPAN>.<SPAN style="COLOR: black">Substring</SPAN>(<SPAN style="COLOR: black">slash</SPAN> + 1));<BR>&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: blue">return</SPAN> <SPAN style="COLOR: blue">new</SPAN> <SPAN style="COLOR: black">Fraction</SPAN>(<SPAN style="COLOR: black">numerator</SPAN>, <SPAN style="COLOR: black">denominator</SPAN>);<BR></SPAN><B><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'">&nbsp; }<BR></SPAN></B><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'">&nbsp; ...<BR></SPAN><B><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'">}</SPAN></B></P>
<P>Notice that instead of implementing an ITypeConverter interface, the FractionTypeConverter derives from the TypeConverter base class. The TypeConverter class provides a set of virtual methods that any custom type converter can implement or not, depending on its needs. The base class implementations of the virtual methods provide default functionality that will be applicable in a large percentage of cases, making it justified in many cases to rely on the base class implementation.</P>
<P>In the case of components, VS.NET requires the class to implement the IComponent interface and will use the abstract members to hook up with arbitrary components. On the other hand, for type converters, VS.NET requires a derivation from the TypeConverter base class, calling the virtual methods that may or may not be overridden in the derived class. So why the difference?</P>
<P>One major difference between interfaces and base classes is that interfaces require all members to be implemented, while base classes only require abstract members to be implemented, while allowing virtual members to be overridden optionally. In the case of IComponent vs. TypeConverter, IComponent has two members, making it easy to implement. TypeConverter, on the other hand, provides thirty-two, eleven of which are virtual. That's a heck of a lot of functionality to require a type converter to implement, especially if the majority of the implementation is common amongst type converters, making a base class seem like a darn good idea in the case of a type converter.</P>
<P>On the other hand, because .NET only supports a single base class, a custom type converter must derive from only TypeConverter. A type converter can't also be a Control, for example. Interfaces, of course, have no such limitation. A class can implement any number of interfaces.</P>
<H1>Where Are We</H1>
<P>How do you decide between interfaces and base classes for your polymorphism? I recommend taking some clues from the .NET framework itself. In the case where the set of methods doesn’t expose a large amount of common functionality across many implementations, prefer interfaces. On the other hand, where there is a large amount of common functionality, prefer base classes (all other things being equal). One exception to this rule that you should prefer interfaces for remote objects to completely separate the client and the server from each other.</P>
<P>And, if you want the maximum of flexibility and ease of implementation, you can define an interface, depend on that interface from your clients but also provide a base implementation of that interface. For example, .NET could define the ITypeConverter interface, which VS.NET could depend on, but still provide a TypeConverter base class that custom type converters could derive from to provide ease of implementation, e.g.</P>
<P class=MsoNormal><SPAN style="FONT-SIZE: 10pt; COLOR: green; FONT-FAMILY: 'Courier New'">// imaginary<BR></SPAN><SPAN style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'">interface</SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'"> <SPAN style="COLOR: black">System</SPAN>.<SPAN style="COLOR: black">ComponentModel</SPAN>.<SPAN style="COLOR: black">ITypeConverter</SPAN> {...}<BR></SPAN><SPAN style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'">class</SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'"> <SPAN style="COLOR: black">System</SPAN>.<SPAN style="COLOR: black">ComponentModel</SPAN>.<SPAN style="COLOR: black">TypeConverter</SPAN> : <SPAN style="COLOR: black">ITypeConverter</SPAN> {...}<BR></SPAN><SPAN style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'">class</SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'"> <SPAN style="COLOR: black">MyNamespace</SPAN>.<SPAN style="COLOR: black">MyCustomTypeConverter</SPAN> : <SPAN style="COLOR: black">TypeConverter</SPAN> {...}</SPAN></P>
<P>In fact, .NET does just that for the IComponent interface and the Component base class:</P>
<P class=MsoNormal><SPAN style="FONT-SIZE: 10pt; COLOR: green; FONT-FAMILY: 'Courier New'">// real<BR></SPAN><SPAN style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'">interface</SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'"> <SPAN style="COLOR: black">System</SPAN>.<SPAN style="COLOR: black">ComponentModel</SPAN>.<SPAN style="COLOR: black">IComponent</SPAN> : <SPAN style="COLOR: black">IDisposable</SPAN> {...}<BR></SPAN><SPAN style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'">class</SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'"> <SPAN style="COLOR: black">System</SPAN>.<SPAN style="COLOR: black">ComponentModel</SPAN>.<SPAN style="COLOR: black">Component</SPAN> :<SPAN style="COLOR: black"> System</SPAN>.<SPAN style="COLOR: black">ComponentModel</SPAN>.<SPAN style="COLOR: black">IComponent</SPAN>, ... {...}<BR></SPAN><SPAN style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'">class</SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'"> <SPAN style="COLOR: black">MyCustomComponent</SPAN> : <SPAN style="COLOR: black">Component</SPAN> {...}</SPAN></P>
<P>Providing both an interface and a base class requires more work, but it does help you to depend less on implementation details when designing a polymorphic architecture, especially for extension by 3<SUP>rd</SUP> parties.</P>
<H1>How I Figured This Out</H1>
<P class=MsoNormal>The answer to this question is based on years of designing C++ base classes and COM interfaces as well as an understanding of the .NET framework and how Microsoft chose to answer this question. I also ran my ideas past Michael before posting this answer.</P>
<H1>How To Avoid This In The Future</H1>
<P class=MsoNormal>I think Michael did the exact right thing when he noticed the difference between interfaces and base classes as used for polymorphism in .NET -- he asked. Design questions like these always have an answer that boils down to "it depends," and the best way to get answers to these kinds of questions is to ask other folks that have thought the same thoughts.</P></p>
  		<p style="MARGIN-RIGHT: 0px">
			<font size="2"><SPAN 
style="FONT-SIZE: 12pt; FONT-FAMILY: 'Times New Roman'; mso-fareast-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA">
		</p>
<H1>Feedback</H1>
<P><A href="mailto:askthewonk@sellsbrothers.com?subject=Feedback on 'Should I choose interfaces or base classes for polymorphism?'">I have 
feedback on this Ask The Wonk answer</A></P></SPAN></FONT></body>
</html>

